In this project, we implemented a simple file system on a virtual hard disk. First of all,  kufs_create_disk method initialized the virtual hard disk, creating a txt file filled with garbage character '~' which has the requested size(5 in test.c) * 1024(size in bytes of each block). Then, kufs_mount reads this virtual hard disk & copies into a buffer string. This method also allocates memory to 2 global arrays: allocated_blocks and open_file_table, which respectively keep count of the blocks that are allocated to various files & the files that are currently open. FAT is designed to be an array of fatEntry structs. kufs_create method traverses this array(called disk_node), and initializes the first null entry. It allocates appropriate memory fot the fatEntry class and its member variables. The open status of a file when it's created is 0 and no blocks are allocated to it yet. kufs_open method changes the open value of the file from 0(if never opened before or closed) to 1. Then, it updates the open_file_table accordingly. kufs_close closes the file(if it is open), and also updates the open_file_table accordingly. kufs_delete removes the info about the blocks that have been allocated to the file from the global allocated_blocks array. Then, it frees the member variables of the file's corresponding fatEntry from disk_node & nullifies that disk_node entry. kufs_write method writes n bytes of the given string (n also given) to the file. It deals with two possible cases separately: When current position + n exceeds the current block & when it doesnt. Latter is easier to implement, the first one, however; required splitting the string to be written into two parts, writing the first part to the current block to fill it, finding the next block if there is one(or allocating a new one if there isn't), updating the file position to that block and finally, writing the remaining part of the string to that new block. Same duality applies for kufs_read, in which we handled the case when # of bytes to be read are completely in the current block & the case in which # of bytes to be read exceeds the current block. kufs_seek method seeks the n'th position of the file, which requires finding the n'th position from the file's allocated blocks. kufs_dump_fat prints the names of & the blocks allocated to existing files and is mainly used for debugging. And finally, kufs_umount writes the information stored in FAT into the first block of the hard-disk, then frees FAT & any allocated memory associated with it.


Note:while deleting a file, it is taking time so when we wait for 3-5 seconds, the code is terminating correctly,just for convinience.
