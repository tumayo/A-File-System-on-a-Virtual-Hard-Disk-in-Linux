# A-File-System-on-a-Virtual-Hard-Disk-in-Linux
* __kufs_create_disk__ method initialized the virtual hard disk, creating a txt file filled with garbage character '~' which has the requested size(5 in test.c) * 1024(size in bytes of each block).
* __kufs_mount__ reads this virtual hard disk & copies into a buffer string. This method also allocates memory to 2 global arrays: allocated_blocks and open_file_table, which respectively keep count of the blocks that are allocated to various files & the files that are currently open. FAT is designed to be an array of fatEntry structs.
* __kufs_create__ method traverses this array (called disk_node), and initializes the first null entry. It allocates appropriate memory fot the fatEntry class and its member variables. The open status of a file when it's created is 0 and no blocks are allocated to it yet.
* __kufs_open__ method changes the open value of the file from 0 (if never opened before or closed) to 1. Then, it updates the open_file_table accordingly.
* __kufs_close__ closes the file(if it is open), and also updates the open_file_table accordingly. kufs_delete removes the info about the blocks that have been allocated to the file from the global allocated_blocks array. Then, it frees the member variables of the file's corresponding fatEntry from disk_node & nullifies that disk_node entry.
* __kufs_write__ method writes n bytes of the given string (n also given) to the file.

_It deals with two possible cases separately:_ when current position + n exceeds the current block & when it doesn't. Latter is easier to implement, the first one, however; required splitting the string to be written into two parts, writing the first part to the current block to fill it, finding the next block if there is one(or allocating a new one if there isn't), updating the file position to that block and finally, writing the remaining part of the string to that new block. Same duality applies for kufs_read, in which we handled the case when # of bytes to be read are completely in the current block & the case in which # of bytes to be read exceeds the current block. kufs_seek method seeks the n'th position of the file, which requires finding the n'th position from the file's allocated blocks. kufs_dump_fat prints the names of & the blocks allocated to existing files and is mainly used for debugging. And finally, kufs_umount writes the information stored in FAT into the first block of the hard-disk, then frees FAT & any allocated memory associated with it.
\
\
Note: while deleting a file, it is taking time so when we wait for 3-5 seconds, the code is terminating correctly,just for convinience.
